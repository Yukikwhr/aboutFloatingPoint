# 浮動小数点のバイアス表現について

バイアス表現について，簡単に解説してみます（わかりにくかったらごめん）

## 仮数部の正規化について

まず，本題に入る前に仮数部の正規化についてなんだけど，
実際のコンピュータの中身では，2進数で，
**0.M**ではなく，
**1.M**になるように正規化される場合があり，バイアス表現ではこちらを用います．
（2進数だと必ず整数部は1になるので，仮数部を1bit節約できるメリットがありますね）

## バイアス表現してみる

上の正規化にならって，7.25(10進)をバイアス表現してみます．
まず，下記のように

* 7.25(10進)=111.01(2進数)=1.1101*2^2

となるので，

* 符号S=0
* 仮数部M=1101

となります．
続いて指数部Eですが，下記のように※バイアス値127を加えたものになります．

* 2+127=129(10進)=10000001(2進)

になります．
つまり，7.25のバイアス表現は
**0 10000001 1101000....0**
となります．

## ※なぜバイアス値を加えるのか

指数部8bitで補数表現を用いた場合，
**-127～128で表現できるところを0～255**に変換するためです．
じゃあ，なぜこんな変換をするかと言うと，数値同士の大小比較を単純化するためです．
例として，0.5(10進)と2(10進)を浮動小数点表示で大小比較してみます．

* 2について，
2(10進)=10(2進)=1.0*2^1となり，
0 00000001 0000....0
となります．

* 0.5は，
0.5(10進)=0.1(2進)=1.0*2^(-1)となります．
ここで，指数部はマイナスとなっているから補数表現を使うとすると
0 11111111 0000....0
となります．

この状態で2つの値の比較を行う（比較は最上位ビットから見ていきます）と，
符号ビットは等しいので飛ばし，指数部の比較をします．
もちろん，最上位ビットが1でマイナスだから，0.5の方が小さいということは明らかなのですが，
実際に演算回路を作るときには「指数部の最上位ビットを確認する回路」が必要ということになってしまいます．

<br>

つまり，設計の都合上，単純に値を比較して，**11111111 > 00000001** となるようにしたいので，
コンピュータの内部では，**-127～128で表現できるところを0～255に変換して(バイアス値127を加えて)**，
ユーザーが見るときなどはもとに戻すという方式を取るということです．
2と0.5をバイアス表現するとそれぞれの指数部は**10000000**と**01111110**になるので，
単純な値の比較で**2 > 0.5**となります．

<br>

もちろん，バイアス表現でそのまま四則演算を行うと値がおかしくなってしまうので，
四則演算をするときは，また，それぞれ修正するステップがあるみたいです．
（もっと詳細を勉強したい場合は参考文献を見てみてください）

<br>

## 参考文献＆URL

* パタヘネ コンピュータの構成と設計 第5版 上
* [東北大の計算機工学](http://www.vision.is.tohoku.ac.jp/files/1814/9359/7662/3rd.pdf)