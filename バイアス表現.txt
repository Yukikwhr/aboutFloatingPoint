上のバイアス表現について，簡単に解説してみます（わかりにくかったらごめん）

まず，本題に入る前に仮数部の正規化についてなんだけど，
実際のコンピュータの中身では，2進数で，
0.Mになるようには正規化されないで，
1.Mになるように正規化される場合があり，バイアス表現ではこちらを用います．
（2進数だと必ず整数部は1になるので，仮数部を1bit節約できるメリットがありますね）

これを踏まえて7.25(10進)をバイアス表現してみます．
まず，2進数になおすと111.01となるので，これを正規化すると，
1.1101*2^2
となります．
よって，
符号S=0
仮数部=1101
となりますが，指数部は※バイアス値127を加えた
129(10進)=10000001(2進)
になります．
つまり，7.25のバイアス表現は
0 10000001 1101000....0
となります．

※なぜバイアス値を加えるのか
指数部8bitで補数表現を用いた場合，
-127~128で表現できるところを0~255に変換するためです．
じゃあ，なぜこんな変換をするかと言うと，数値同士の大小比較を単純化するためです．
例として，0.5(10進)と2(10進)を浮動小数点表示で大小比較してみます．
まず，2について，
2(10進)=10(2進)=1.0*2^1となり，
0 00000001 0000....0
となります．

同様に0.5は，
0.5(10進)=0.1(2進)=1.0*2^(-1)となります．
ここで，指数部はマイナスとなっているから補数表現を使うとすると
0 11111111 0000....0
となります．

この状態で2つの値の比較を行う（比較は最上位ビットから見ていきます）と，
符号ビットは等しいので飛ばし，指数部の比較をします．
もちろん，最上位ビットが1でマイナスだから，0.5の方が小さいということは明らかなのですが，
実際に演算回路を作るときには「指数部の最上位ビットを確認する回路」が必要ということになってしまいます．

つまり，設計の都合上，単純に値を比較して，11111111 > 00000001 となるようにしたいので，
コンピュータの内部では，-127~128で表現できるところを0~255に変換して，
ユーザーが見るときなどはもとに戻すという方式を取るということです．
2と0.5をバイアス表現するとそれぞれの指数部は10000000と01111110になるので，
単純な値の比較で2 > 0.5となります．
もちろん，バイアス表現でそのまま四則演算を行うと値がおかしくなってしまうので，
四則演算をするときは，また，それぞれ修正するステップがあるみたいです．
（もっと詳細を勉強したい場合は参考文献を見てみてください）

長々と申し訳ない...

参考文献＆URL
・パタヘネ コンピュータの構成と設計 第5版 上
・http://www.vision.is.tohoku.ac.jp/files/1814/9359/7662/3rd.pdf
